#!/usr/bin/env bash

# This script provides a collection of utility functions for quickly searching and opening
# configuration files, scripts, and directories using fzf and other command-line tools.

# SCRIPT_NAME=$(basename "$0")

# Dependency check
check_dependencies() {
  local missing=()
  for cmd in "$@"; do
    command -v "$cmd" >/dev/null || missing+=("$cmd")
  done
  if ((${#missing[@]})); then
    echo "Missing dependencies: ${missing[*]}" | sed 's/ /, /g'
    exit 1
  fi
}

check_dependencies fzf eza tree xargs realpath

# Load CONFIG_PATHS and SCRIPT_PATHS
eval source "$HOME/.config/shell/paths"

# Helper: Clean and resolve selected paths, then open in editor
open_selected_files() {
  local header="$1"
  shift

  local selected=$(printf '%s\n' "$@" | sed "s|$HOME|~|" |
    fzf -m --header="$header" --header-first |
    sed "s|~|$HOME|" | sed 's/[*@/]$//')

  [[ -z "$selected" ]] && return

  while IFS= read -r filepath; do
    [[ -z "$filepath" ]] && continue
    local resolved=$(realpath "$filepath" 2>/dev/null)
    [[ -w "$resolved" ]] && "$EDITOR" "$resolved" || sudo -e "$resolved"
  done <<<"$selected"
}

# Function: Search config files
search_configs() {
  local file_paths=()
  for base in "${!CONFIG_PATHS[@]}"; do
    for entry in ${CONFIG_PATHS[$base]}; do
      local target="$base/$entry"

      if [[ "$entry" =~ [\(\)\|\*\+\?] ]]; then
        local pattern="$base/$entry"
        pattern="${pattern//./\\.}"

        while IFS= read -r f; do
          file_paths+=("$f")
        done < <(find "$base" -regextype posix-extended -type f -regex "$pattern" 2>/dev/null)
      else
        [[ -e "$target" ]] || continue
        while IFS= read -r f; do
          file_paths+=("$f")
        done < <(find "$target" -type f 2>/dev/null)
      fi
    done
  done
  open_selected_files "search_configs" "${file_paths[@]}"
}

# Function: Search script files
search_scripts() {
  local file_paths=()
  for base in "${!SCRIPT_PATHS[@]}"; do
    for entry in ${SCRIPT_PATHS[$base]}; do
      local target="$base/$entry"

      if [[ "$entry" =~ [\(\)\|\*\+\?] ]]; then
        local pattern="$base/$entry"
        pattern="${pattern//./\\.}"

        while IFS= read -r f; do
          file_paths+=("$f")
        done < <(find "$base" -regextype posix-extended -type f -executable -regex "$pattern" 2>/dev/null)
      else
        [[ -e "$target" ]] || continue
        while IFS= read -r f; do
          file_paths+=("$f")
        done < <(find "$target" -type f 2>/dev/null)
      fi
    done
  done
  open_selected_files "search_scripts" "${file_paths[@]}"
}

# Function: Search files in current directory
search_files_cwd() {
  local files=$(eza -1af --git-ignore --color=never -I ".git" |
    grep -vE '/$' | grep -vE '^\.\.?$' | sed 's/[*@/]$//')
  open_selected_files "search_files_cwd" "$files"
}

# Function: Search nested files
search_nested_files_cwd() {
  local files=$(tree -Fifa --gitignore -I ".git" --noreport |
    grep -v '/$' | grep -vE '^\./\.\.?$' |
    sed 's|^\./||; s/[*@/]$//')
  open_selected_files "search_nested_files_cwd" "$files"
}

# Function: Select directory in current directory
select_dir_cwd() {
  local dir=$(eza -aD --git-ignore -I ".git" | grep -vE '^\.\.?$' |
    fzf --header="select_dir_cwd" --header-first)
  [[ -n "$dir" ]] && cd "$dir"
}

# Function: Select nested directory
select_nested_dir_cwd() {
  local dir=$(tree -fida --gitignore -I ".git" --noreport |
    tail -n +2 | grep -vE '^\./\.\.?$' |
    sed 's|^\./||; s/[*@/]$//' |
    fzf --header="select_nested_dir_cwd" --header-first)
  [[ -n "$dir" ]] && cd "$dir"
}

# Show usage
usage() {
  echo "Usage: peekr <action_name> [args...]"
  echo
  echo "Available functions:"
  echo "  - search_configs"
  echo "  - search_scripts"
  echo "  - search_files_cwd"
  echo "  - search_nested_files_cwd"
  echo "  - select_dir_cwd"
  echo "  - select_nested_dir_cwd"
  echo
  echo "Run '$SCRIPT_NAME -h' or '--help' for usage."
  exit 0
}

# Entry point
case "$1" in
-h | --help)
  usage
  ;;
"")
  :
  ;;
*)
  if declare -f "$1" >/dev/null; then
    func="$1"
    shift
    "$func" "$@"
  else
    echo "Error: '$1' is not a valid action name."
    echo
    usage
  fi
  ;;
esac
